## 1.1.安装

**引入依赖**

使用前，**必须**先引入 `crane4j-spring-boot-starter` 依赖，然后再引入 `crane4j-mybatis-plus-extension` 依赖：

~~~xml
<!-- 先引入 crane4j-spring-boot-starter -->
<dependency>
    <groupId>top.crane4j</groupId>
    <artifactId>crane4j-spring-boot-starter</artifactId>
    <version>${last-version}</version>
</dependency>
<!-- 先引入 mp 扩展包 -->
<dependency>
    <groupId>top.crane4j</groupId>
    <artifactId>crane4j-mybatis-plus-extension</artifactId>
    <version>${last-version}</version>
</dependency>
~~~

**启用配置**

**必须**先在启动类上添加 `@EnableCrane4j` 注解启用 `crane4j` 基础配置，然后再添加 `@EnableCrane4jMyabtisPlusExtension` 注解启用扩展模块配置：

~~~java
@EnableCrane4jMyabtisPlusExtension // 启用扩展模块
@EnableCrane4j // 启用基本配置
@SpringBootApplication
public class MbossChargeApplication {
    public static void main(String[] args) {
        SpringApplication.run(MbossChargeApplication.class, args);
    }
}
~~~

## 1.2.注册Mapper

该步骤不是必须的，当启用配置后，在项目启用时，将会自动扫描 Spring 上下文中实现了 `BaseMapper` 的 `bean`，并将其适配为基于 `BaseMapper.selectList` 的容器，并注册到 `MpMethodContainerProvider` 中。

用户可以在配置文件中指定仅注册/仅排除指定的 `Mapper` 的 `beanName` ：

~~~yml
crane4j:
 mybatis-plus:
  auto-register-mapper: true # 启动自动注册
  includes: xxxMapper, xxxMapper # 仅注册指定 Mapper
  excludes: xxxMapper, xxxMapper # 仅排除指定 Mapper
~~~

若有必要，用户也可以指定 `auto-register-mapper` 为 `false` 关闭自动注册，而通过获取 `MpBaseMapperContainerRegister` 手动注册 `Mapper`：

~~~java
MpBaseMapperContainerRegister register = SpringUtil.getBean(MpBaseMapperContainerRegister.class);
register.registerMapper("xxxMapper", xxxMapper);
~~~

指定的 `mapperName` 即为后文配置中 `Mapper` 名称，自动注册的情况下即为 `beanName`；

## 1.3.基本使用

相对普通容器， `MP` 的扩展容器使用起来会有一点区别。

当使用时，需要在 `@Assemble` 注解中指定容器的 `ContainerProvider`，并且通过 `container` 函数指定容器：

~~~java
public class Foo {
    @Assemble(
    	container = "container('fooMapper')", // 指定调哪一个 Mapper，名称为其在 Spring 中的 beanName
        containerProvider = "mpMethodContainerProvider" // 固定为提供者在 Spring 上下文中的 beanName
    )
    private Integer id;
    private String name;
}
~~~

或使用 `AssembleByMP` 组合注解简化：

~~~java
public class Foo {
    @AssembleByMP(container = "container('fooMapper')")
    private Integer id;
    private String name;
}
~~~

当执行装配时，数据源等同于基于 `id` 批量查询出来的 `Bean` 对象，SQL 同 `select * from foo where id in ?`。 

:::tip

其中，`container()` 是一个在 `MPMethodContainerProvider` 中固定的方法名称，表示在提供者中获取容器。

:::

## 1.4.指定字段

表达式中的 `container()` 本质上是通过表达式引用 `MpBaseMapperContainerRegister` 中的 `container()` 重载方法。

该方法支持四种写法，可以分别指定查询的外键字段与查询的字段：

- **根据主键查询全部字段**：方法为 `container('${mapperName}')` 等同于 `select * from ${table} where ${id} in ?` ；
- **根据主键查询指定字段**：方法为 `container('${mapperName}', [${column1}, ${column2}...])`，等同于 `select ${column1}, ${column2}... from table where id in ?`；
- **根据指定外键查询指定字段**：方法为 `container('${mapperName}', ${query_column}, [${column1}, ${column2}...])`，等同于 `select ${column1}, ${column2}... from table where ${query_column} in ?`；
- **根据指定晚间查询全部字段**：方法为 `container('${mapperName}', ${query_column}`，等同于 `select * from table where id in ?`；

`crane4j` 将根据调用方法的不同，构建不同的 `QueryWrapper` 去查询数据，并将查出来的 `Bean` 集合根据指定的外键或主键分组后作为数据源，提供给装配操作使用。

:::tip

`crane4j` 默认将被 `@TableId` 注解的属性作为主键

:::

## 1.5.表字段自动转换

在配置表达式时，查询外键或者查询的字段可以是数据库表字段，也可以是 `Bean` 的属性名，当是后者时，将会自动将其转换为 `@TableField` 上声明的实际字段。

比如，现有 `Bean` 如下：

~~~java
public class Foo {
    @TableId
    private Integer id;
    @TableField("user_name")
    private String name;
    @TableField("user_age")
    private Integer age;
}
~~~

然后装配配置如下：

~~~java
public class Foo {
    @AssembleByMP(
        container = "container('fooMapper', 'name', 'age')"
    )
    private Integer id;
    private String name;
    private String age;
}
~~~

最终执行的 SQL 为：`select user_age, user_name foo where user_name in ?`。

:::tip

由于数据源需要一个 key 用于分组，因此当指定了查询外键和查字段，但是查询字段又没有包含查询外键时，将会自动在查询字段末尾拼接上查询外键

:::
