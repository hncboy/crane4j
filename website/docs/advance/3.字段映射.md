## 3.0.概述

<img src="./image-20230220182129822.png" alt="image-20230220182129822" style="zoom: 50%;" />

字段映射是装配操作的一部分，用于描述将数据源对象的哪些字段的值会填充到目标对象哪些字段上。

## 3.1.映射属性

字段映射配置的用法有点像 `MapStruct` ，在当我们通过 `@Assemble` 注解声明一个装配操作时，我们可以在 `props` 中配置字段映射：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = {
            @Mapping(src = "studentName", ref = "name"),
            @Mapping(src = "studentClassName", ref = "className")
        }
    )
    private Integer id;
    private String name;
    private String className;
}
~~~

上述示例表示将根据 `id` 查出 `Student` 对象后，将：

- `Student.studentName` 映射到 `StudentVO.name`；
- `Student.studentClassName` 映射到 `StudentVO.className`；

默认的两个实现一个底层基于 `Hutool` 的反射调用实现，另一个基于 `ReflectAsm` 实现，而两者支持一定程度的自动类型转换。

:::tip

`crane4j` 的反射体系参照了 `Mybatis`，也是由一个类似的反射工厂的类 `PropertyOperator` 统一完成，用户可以替换默认实现以便使全局的反射调用按用户的需求来完成。

:::

## 3.2.映射对象

当在 `@Mapping` 注解不指定源字段 `src` 时，表示直接将整个数据源对象作为映射值：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = @Mapping(ref = "student")
    )
    private Integer id;
    private Student student;
}
~~~

上述示例表示将根据 `id` 查出 `Student` 对象后，直接将 `Student` 对象塞入 `StudentVO.student` 字段中。

一般该配置适合用于在组装对象，或者数据源本身就是某个字典值或者枚举值的情况。

## 3.3.映射 key 字段

当在 `@Mapping` 注解不指定引用字段 `ref` 时，表示直接将映射值映射到 `key` 字段上：

~~~java
public class StudentVO {
    @Assemble(
        container = "gender", 
        props = @Mapping(src = "name")
    )
    private String sex;
}
~~~

上述示例表示将根据 `StudentVO.sex` 查出性别字典对象 `Gender` 后，将中对应的 `Gender.name` 在映射会 `StudentVO.sex` 字段。

## 3.4.批量映射

实际场景中，会存在 `key` 字段是**集合数组或者按分隔符拼接的字符串格式**的情况，即**一次操作对应多个 `key` 值**：

~~~java
private String idStr; // key字段为按分隔符拼接的字符串，比如：a, b, c
private Set<Integer> idList; // key字段为集合，比如：[a, b, c];
private Integer[] idArray; // key字段为数组，比如：[a, b, c];
~~~

针对多 `key` 值字段映射，需要指定专门的装配操作处理器 `MultiKeyAssembleOperationHandler`：

~~~java
public class StudentVO {
    @Assemble(
        container = "teacher", 
        props = @Mapping(src = "name", ref = "teacherNames")
        handler = MultiKeyAssembleOperationHandler.class
    )
    private String teacherIds; // 格式默认支持 1, 2, 3 格式
    private List<String> teacherNames; // 填充的格式默认为 src1, src2, src3
}
~~~

上述示例表示，根据 `teacherIds` 字段字符串中通过分隔符分割的多个 `key` 值，查出关联的多个 `Teacher` 对象，然后将 `Teacher` 集合映射为 `Teacher.name` 集合并塞入 `StudentVO.teacherNames` 字段中。

该字段映射同样**遵循普通字段映射的语义**，比如对象映射：

~~~java
public class StudentVO {
    @Assemble(
        container = "teacher", 
        props = @Mapping(ref = "teachers")
        handler = MultiKeyAssembleOperationHandler.class
    )
    private String teacherIds; // 格式默认支持 1, 2, 3 格式
    private List<Teacher> teachers;
}
~~~

在批量映射的情况下，返回的对象都将会是**数据源对象或数据源对象的属性集合**。

:::tip

由于实际上字段映射都是通过装配处理器完成的，因此用户也可以实现 `AssembleOperationHandler` 接口，自定义装配处理器以便支持更多映射方式。

:::

## 3.5.映射模板

有时候一次装配操作会配置很多的字段映射，为了保持代码的整洁避免配置臃肿，可以使用字段映射模板。

比如，现有字段配置如下：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", 
        props = {
            @Mapping(src = "studentName", ref = "name"),
            @Mapping(src = "studentClassName", ref = "className"),
            @Mapping(src = "studentTeacherName", ref = "teacherName")
        }
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
}
~~~

我们创建一个模板类 `StudentMappingTemplate`，并将 `props` 中的映射配置通过 `@MappingTemplate` 移至模板类：

~~~java
@MappingTemplate({
    @Mapping(src = "studentName", ref = "name"),
    @Mapping(src = "studentClassName", ref = "className"),
    @Mapping(src = "studentTeacherName", ref = "teacherName")
})
private static class StudentMappingTemplate {}
~~~

然后再在 `@Assemble` 通过 `propTemplates` 引入模板即可：

~~~java
public class StudentVO {
    @Assemble(
        container = "student", propTemplates = StudentMappingTemplate.class
    )
    private Integer id;
    private String name;
    private String className;
    private String teacherName;
}
~~~

通过模板引入的字段映射配置与通过 `@Assemble.props` 声明的配置效果一致，并且两者可以同时存在，解析的顺序遵循就近原则。