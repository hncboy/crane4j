(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{273:function(t,s,v){t.exports=v.p+"assets/img/image-20230220150040070.63150c20.png"},292:function(t,s,v){"use strict";v.r(s);var _=v(14),r=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[s("img",{attrs:{src:v(273),alt:"image-20230220150040070"}})]),t._v(" "),s("p",[t._v("基于注解的字典项、关联表与枚举值处理框架。")]),t._v(" "),s("h3",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),s("p",[t._v("在我们日常开发中，常常会遇到一些“根据 A 的 key 值拿到 B，再把 B 的属性映射到 A”的需求，比如典型的：")]),t._v(" "),s("ul",[s("li",[t._v("对象属性中存有字典 id，需要获取对应字典值并填充到对象中；")]),t._v(" "),s("li",[t._v("对象属性中存有外键，需要关联查询对应的数据库表实体，并获取其中的指定属性填充到对象中；")]),t._v(" "),s("li",[t._v("对象属性中存有枚举，需要将枚举中的指定属性填充到对象中；")])]),t._v(" "),s("p",[t._v("这些繁琐的数据组装工作涉及五花八门的数据源，比如字典项、配置项、枚举常量，甚至是一些关联数据的查询，它们往往大量的、重复的出现，但是在不同的接口需求中又会有细微的区别，为了处理它们又需要写大量样板代码，实在让人心烦。")]),t._v(" "),s("p",[s("code",[t._v("crane4j")]),t._v(" 旨在为了解决这种烦恼而生，它是一套基于注解的数据填充框架，仅需通过注解配置，即可优雅高效的完成不同数据源、不同类型、不同类型的字段数据填充，屏蔽繁琐的字段填充，专注于核心业务。")]),t._v(" "),s("h3",{attrs:{id:"特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("多样的数据源支持")]),t._v("：支持将枚举、普通键值对缓存，甚至实例方法或静态方法作为数据源，也支持通过简单的自定义扩展兼容更多类型的数据源，并且对所有类型数据源都提供缓存支持；")]),t._v(" "),s("li",[s("strong",[t._v("强大的字段映射能力")]),t._v("：通过注解即可完成不同类型字段之间映射自动转换，支持模板、排序、分组、自动填充嵌套对象等等功能，除 JDK 原生反射外还支持更快的字节码调用；")]),t._v(" "),s("li",[s("strong",[t._v("高度的可扩展性")]),t._v("：所有主要组件均可由用户自由替换，配合 Spring 的依赖注入可实现轻松优雅的完成自定义扩展。")]),t._v(" "),s("li",[s("strong",[t._v("丰富的扩展功能")]),t._v("：引入 Spring 后，还提供包括方法返回值与方法入参参数的自动填充，多线程填充，自定义符合注解以及表达式等可选功能；")])]),t._v(" "),s("h3",{attrs:{id:"参与贡献和技术支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参与贡献和技术支持"}},[t._v("#")]),t._v(" 参与贡献和技术支持")]),t._v(" "),s("p",[t._v("如果在使用中遇到了问题、发现了 bug ，又或者是有什么好点子，欢迎在 issues 或者加入 QQ 群：540919540 反馈！")])])}),[],!1,null,null,null);s.default=r.exports}}]);